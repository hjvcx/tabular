#!/usr/bin/python3
'''
Usage:
    tabular [options] [<input> [<output>]]

Options:
    -o <style>, --output-style <style>          Defines style for columns. [default: uhC]
    -i <string>, --input-separator <string>     Defines characters being used as separators. [default:  \t]
    -s, --sticky-separators                     Multiple separators as one. [default: True]
    -t, --trim-empty                            Deletes empty fields at beginning and end of entries. [default: True]
    -n <string>, --names <string>               Defines names of columns (first character of string stands as separator).
    -1, --first-line-header                     If enabled, makes first string perceived as header.
    -f <string>, --fields <string>              Defines specification of output. [default: l0]
    -L <number>, --lines-inspect <number>       Defines number of strings being counted for calculating field sizes. [default: 0]
    -h, --help                                  Open this message.
    -v, --version                               Version check and finish program execution.
'''

from docopt import docopt
import pprint
import sys
import re

settings = {
    'decostyle': '',
    'headerline': 0,
    'columnline': 0,
    'borderline': 0,
    'fields': ['l0'],
    'lines_inspect': 0,
    'names': [],
    'input_separators': [' '],
    'sticky_separators': True,
    'trim_empty': True,
    'fl_header': False,
    'input': None,
    'output': None
}

# Set of chars for drawing a table
charset = {
    'top_left': '',
    'top_mid': '   ',
    'top_right': '',
    'mid_left': '',
    'mid_mid': '   ',
    'mid_right': '',
    'bot_left': '',
    'bot_mid': '   ',
    'bot_right': '',
    'v_filling': '   ',
    'h_filling': '',
    'lbv_filling': '',
    'rbv_filling': '',
    'bh_filling': ''
}

# Number of fields before zero, in zero and after zero when using --fields option
rml_fields = [0, 0, 0]

# Pretty print function
def pretty_printer(data):
    pp = pprint.PrettyPrinter(stream=sys.stderr)
    pp.pprint(data)

# sys.exit() + streams closing
def sysexit(code):
    if settings['input']:
        settings['input'].close()
    if settings['output']:
        settings['output'].close()

    sys.exit(code)

# Stderr print function
def perr(message, exception=None):
        if exception:
            msg = f'{message}: {exception}'
        else:
            msg = message
        print(msg, file=sys.stderr)

# Argument parsing function
def arg_parse():
    # Getting parameters and options dictionary then print it (for understanding)
    args = docopt(__doc__)
    # pretty_printer(args)
    exit_trigger = False

    # Working with options and parameters using conditions
    if args['--output-style']:
        try:
            list_args = list(args['--output-style'])
            list_args_l = list(args['--output-style'].lower())

            pattern = r'[AUauHBChbc]+'
            matches = re.fullmatch(pattern, args['--output-style'])

            if not matches:
                raise Exception('wrong character')
            if sorted(set(list_args_l)) != sorted(list_args_l):
                raise Exception('duplicated characters')
            if 'a' in set(list_args) and 'u' in set(list_args):
                raise Exception('argument cannot contain "a" and "u" both')
            if 'a' not in set(list_args) and 'u' not in set(list_args):
                raise Exception('argument must contain "a" or "u"')
        except Exception as e:
            perr('Invalid argument in option --output-style', e)
            exit_trigger = True

        if 'a' in list_args:
            settings['decostyle'] = 'ASCII'
        else:
            settings['decostyle'] = 'Unicode'

        if 'h' in list_args:
            settings['headerline'] = 1
        elif 'H' in list_args:
            settings['headerline'] = 2

        if 'c' in list_args:
            settings['columnline'] = 1
        elif 'C' in list_args:
            settings['columnline'] = 2

        if 'b' in list_args:
            settings['borderline'] = 1
        elif 'B' in list_args:
            settings['borderline'] = 2

    if args['--fields']:
        try:
            pattern = r'^([lrjc]\d+)+$'
            matches = re.findall(pattern, args['--fields'])
            for c in args['--fields']:
                if c not in 'lrjc1234567890':
                    raise Exception('wrong character')
            if not matches:
                raise Exception('bad structure')
            if args['--fields'].count('0') > 1:
                raise Exception('cannot be more than one "0"')
        except Exception as e:
            perr('Invalid argument in option --fields', e)
            exit_trigger = True

        settings['fields'] = re.findall(r'([a-zA-Z]\d+)', args['--fields'])

    if args['--lines-inspect']:
        try:
            pattern = r'^\d+$'
            matches = re.findall(pattern, args['--lines-inspect'])
            if not matches:
                raise Exception('argument must be a number')
        except Exception as e:
            perr('Invalid argument in option --lines-inspect', e)
            exit_trigger = True

        if not exit_trigger:
            settings['lines_inspect'] = int(args['--lines-inspect'])

    if not args['--sticky-separators']:
        if not args['--input-separator'] == ' \t':
            settings['sticky_separators'] = False

    if args['--input-separator']:
        settings['input_separators'] = list(args['--input-separator'])

    if args['--names']:
        delimiter = args["--names"][0]
        settings['names'] = args['--names'][1:].split(delimiter)

    if not args['--trim-empty']:
        if not args['--input-separator'] == ' \t':
            settings['trim_empty'] = False

    if args['--first-line-header']:
        try:
            if settings['names']:
                raise Exception('cannot be used with --names')
            settings['fl_header'] = True
        except Exception as e:
            perr('Invalid --first-line-header usage', e)
            exit_trigger = True

    if args['--version']:
        print('tabular v0.0.1')
        sys.exit()

    if exit_trigger:
        sys.exit(1)

    # Trying to initialize input and output streams
    try:
        if args['<input>']:
            settings['input'] = open(args['<input>'])
        else:
            settings['input'] = sys.stdin
    except Exception as e:
        perr('Cannot open input', e)
        sys.exit(1)

    try:
        if args['<output>']:
            settings['output'] = open(args['<output>'], 'w+')
        else:
            settings['output'] = sys.stdout
    except Exception as e:
        perr('Cannot open output', e)
        sys.exit(1)

    # pretty_printer(settings)

# Reading first n rows where n is -L option value
def read_first_part():
    rows = []

    if settings['lines_inspect'] != 0:
        for _ in range(settings['lines_inspect']):
            row = settings['input'].readline()
            if not row:
                break
            rows.append(row.rstrip('\n\r'))
    else:
        while True:
            row = settings['input'].readline()
            if not row:
                break
            rows.append(row.rstrip('\n\r'))

    return rows

# Function for filtering empty strings in splitted row array
def is_not_empty(string):
    return string != ''

# Making string array from rows divided by --input-separator values
def split_row(row):
    a_row = []
    rpl = settings['input_separators'][0]

    if settings['input_separators'] == [' ', '\t']:
        a_row = row.split()
    else:
        for d in settings['input_separators']:
            if d != rpl:
                row = row.replace(d, rpl)
        if settings['sticky_separators']:
            a_row = list(filter(is_not_empty, row.split(rpl)))
        else:
            a_row = row.split(rpl)

    return a_row

# Calculating maximum lengths of column values
def compute_fields(rows):
    s_rows = []
    if settings['names']:
        s_rows.append(settings['names'])
    for row in rows:
        s_rows.append(split_row(row))
    rows = s_rows

    max_ls = []

    if rows:
        for i in range(max(map(len, rows))):
            max_l = max(len(row[i]) for row in rows if i < len(row))
            max_ls.append(max_l)
    else:
        max_ls = [0]

    return max_ls

# Function of writing top part of borderline
def write_top(fspec):
    line = ''

    line += charset['top_left']
    for i in range(len(fspec)):
        line += charset['bh_filling']*fspec[i]
        if i != len(fspec)-1:
            line += charset['top_mid']
    line += charset['top_right']
    line += '\n'

    settings['output'].write(line)

# Function of writing headerline
def write_mid(fspec):
    line = ''

    line += charset['mid_left']
    for i in range(len(fspec)):
        line += charset['h_filling']*fspec[i]
        if i != len(fspec)-1:
            line += charset['mid_mid']
    line += charset['mid_right']
    line += '\n'

    settings['output'].write(line)

# Function of writing bottom part of borderline
def write_bot(fspec):
    line = ''

    line += charset['bot_left']
    for i in range(len(fspec)):
        line += charset['bh_filling']*fspec[i]
        if i != len(fspec)-1:
            line += charset['bot_mid']
    line += charset['bot_right']
    line += '\n'

    settings['output'].write(line)

# Charset defining function for correct writing of table lines
def set_charset():
    if settings['decostyle'] == 'ASCII' and settings['headerline']:
        charset['h_filling'] = '-'
        charset['mid_mid'] = '---'

    if settings['decostyle'] == 'ASCII' and settings['columnline']:
        charset['v_filling'] = ' | '

    if settings['decostyle'] == 'ASCII' and settings['borderline']:
        charset['bh_filling'] = '-'
        charset['lbv_filling'] = '| '
        charset['rbv_filling'] = ' |'
        charset['top_left'] = '+-'
        charset['top_right'] = '-+'
        charset['bot_left'] = '+-'
        charset['bot_right'] = '-+'
        charset['top_mid'] = '---'
        charset['bot_mid'] = '---'

    if settings['decostyle'] == 'ASCII' and settings['headerline'] and settings['columnline']:
        charset['mid_mid'] = '-+-'

    if settings['decostyle'] == 'ASCII' and settings['headerline'] and settings['borderline']:
        charset['mid_left'] = '+-'
        charset['mid_right'] = '-+'

    if settings['decostyle'] == 'ASCII' and settings['columnline'] and settings['borderline']:
        charset['top_mid'] = '-+-'
        charset['bot_mid'] = '-+-'

    if settings['decostyle'] == 'Unicode' and settings['headerline'] == 1:
        charset['h_filling'] = 'â”€'
        charset['mid_mid'] = 'â”€â”€â”€'
    if settings['decostyle'] == 'Unicode' and settings['headerline'] == 2:
        charset['h_filling'] = 'â•'
        charset['mid_mid'] = 'â•â•â•'

    if settings['decostyle'] == 'Unicode' and settings['borderline'] == 1:
        charset['bh_filling'] = 'â”€'
        charset['lbv_filling'] = 'â”‚ '
        charset['rbv_filling'] = ' â”‚'
        charset['top_left'] = 'â”Œâ”€'
        charset['top_right'] = 'â”€â”'
        charset['bot_left'] = 'â””â”€'
        charset['bot_right'] = 'â”€â”˜'
        charset['top_mid'] = 'â”€â”€â”€'
        charset['bot_mid'] = 'â”€â”€â”€'
    if settings['decostyle'] == 'Unicode' and settings['borderline'] == 2:
        charset['bh_filling'] = 'â•'
        charset['lbv_filling'] = 'â•‘ '
        charset['rbv_filling'] = ' â•‘'
        charset['top_left'] = 'â•”â•'
        charset['top_right'] = 'â•â•—'
        charset['bot_left'] = 'â•šâ•'
        charset['bot_right'] = 'â•â•'
        charset['top_mid'] = 'â•â•â•'
        charset['bot_mid'] = 'â•â•â•'

    if settings['decostyle'] == 'Unicode' and settings['columnline'] == 1:
        charset['v_filling'] = ' â”‚ '
    if settings['decostyle'] == 'Unicode' and settings['columnline'] == 2:
        charset['v_filling'] = ' â•‘ '

    if settings['decostyle'] == 'Unicode' and settings['borderline'] == 1 and settings['columnline'] == 1:
        charset['top_mid'] = 'â”€â”¬â”€'
        charset['v_filling'] = ' â”‚ '
        charset['bot_mid'] = 'â”€â”´â”€'
    if settings['decostyle'] == 'Unicode' and settings['borderline'] == 1 and settings['columnline'] == 2:
        charset['top_mid'] = 'â”€â•¥â”€'
        charset['v_filling'] = ' â•‘ '
        charset['bot_mid'] = 'â”€â•¨â”€'
    if settings['decostyle'] == 'Unicode' and settings['borderline'] == 2 and settings['columnline'] == 1:
        charset['top_mid'] = 'â•â•¤â•'
        charset['v_filling'] = ' â”‚ '
        charset['bot_mid'] = 'â•â•§â•'
    if settings['decostyle'] == 'Unicode' and settings['borderline'] == 2 and settings['columnline'] == 2:
        charset['top_mid'] = 'â•â•¦â•'
        charset['v_filling'] = ' â•‘ '
        charset['bot_mid'] = 'â•â•©â•'

    if settings['decostyle'] == 'Unicode' and settings['borderline'] == 1 and settings['headerline'] == 1:
        charset['mid_left'] = 'â”œâ”€'
        charset['mid_right'] = 'â”€â”¤'
    if settings['decostyle'] == 'Unicode' and settings['borderline'] == 1 and settings['headerline'] == 2:
        charset['mid_left'] = 'â•žâ•'
        charset['mid_right'] = 'â•â•¡'
    if settings['decostyle'] == 'Unicode' and settings['borderline'] == 2 and settings['headerline'] == 1:
        charset['mid_left'] = 'â•Ÿâ”€'
        charset['mid_right'] = 'â”€â•¢'
    if settings['decostyle'] == 'Unicode' and settings['borderline'] == 2 and settings['headerline'] == 2:
        charset['mid_left'] = 'â• â•'
        charset['mid_right'] = 'â•â•£'

    if settings['decostyle'] == 'Unicode' and settings['headerline'] == 1 and settings['columnline'] == 1:
        charset['mid_mid'] = 'â”€â”¼â”€'
    if settings['decostyle'] == 'Unicode' and settings['headerline'] == 1 and settings['columnline'] == 2:
        charset['mid_mid'] = 'â”€â•«â”€'
    if settings['decostyle'] == 'Unicode' and settings['headerline'] == 2 and settings['columnline'] == 1:
        charset['mid_mid'] = 'â•â•ªâ•'
    if settings['decostyle'] == 'Unicode' and settings['headerline'] == 2 and settings['columnline'] == 2:
        charset['mid_mid'] = 'â•â•¬â•'

'''
â”€ â” â”‚ â”ƒ â”„ â”… â”† â”‡ â”ˆ â”‰ â”Š â”‹ â”Œ â” â”Ž â” â” â”‘ â”’ â”“ â”” â”• â”– â”— â”˜ â”™ â”š â”› â”œ â” â”ž â”Ÿ â”  â”¡ â”¢ â”£ â”¤ â”¥ â”¦ â”§ â”¨ â”© â”ª â”« â”¬ â”­ â”® â”¯ â”° â”± â”² â”³
 â”´ â”µ â”¶ â”· â”¸ â”¹ â”º â”» â”¼ â”½ â”¾ â”¿ â•€ â• â•‚ â•ƒ â•„ â•… â•† â•‡ â•ˆ â•‰ â•Š â•‹ â•Œ â• â•Ž â• â• â•‘ â•’ â•“ â•” â•• â•– â•— â•˜ â•™ â•š â•› â•œ â• â•ž â•Ÿ â•  â•¡ â•¢ â•£ â•¤ â•¥ â•¦ â•§
   â•¨ â•© â•ª â•« â•¬ â•­ â•® â•¯ â•° â•± â•² â•³ â•´ â•µ â•¶ â•· â•¸ â•¹ â•º â•» â•¼ â•½ â•¾ â•¿ â–€ â– â–‚ â–ƒ â–„ â–… â–† â–‡ â–ˆ â–‰ â–Š â–‹ â–Œ â– â–Ž â– â– â–‘ â–’ â–“ â–” â–• ðŒ´
'''

# Aligning to width function (j argument of --fields option)
def align_to_width(row, width):
    row = row.split()
    num_spaces = len(row)-1
    len_words = 0

    for r in row:
        len_words += len(r)

    len_spaces = width - len_words
    if num_spaces > 0:
        width_spaces = len_spaces // num_spaces
        extra_spaces = len_spaces % num_spaces
    else:
        width_spaces = 1
        extra_spaces = 0

    for i in range(extra_spaces):
        row[i] += ' '
    new_row = (' '*width_spaces).join(row)

    return new_row

# Making string as row for output and then writing it
def write_row(fspec, row):
    if settings['trim_empty']:
        row = row.strip()
    row = split_row(row)
    new_row = []

    str_row = ''

    try:
        for i in range(rml_fields[0]):
            if i < len(row):
                if settings['fields'][i][0] == 'l':
                    new_row.append(row[i].ljust(fspec[i]))
                if settings['fields'][i][0] == 'r':
                    new_row.append(row[i].rjust(fspec[i]))
                if settings['fields'][i][0] == 'c':
                    new_row.append(row[i].center(fspec[i]))
                if settings['fields'][i][0] == 'j':
                    new_row.append(align_to_width(row[i], fspec[i]))
            else:
                new_row.append(''.ljust(fspec[i]))

        for i in range(rml_fields[0], rml_fields[1]+rml_fields[0]):
            if i < len(row):
                if settings['fields'][rml_fields[0]][0] == 'l':
                    new_row.append(row[i].ljust(fspec[i]))
                if settings['fields'][rml_fields[0]][0] == 'r':
                    new_row.append(row[i].rjust(fspec[i]))
                if settings['fields'][rml_fields[0]][0] == 'c':
                    new_row.append(row[i].center(fspec[i]))
                if settings['fields'][rml_fields[0]][0] == 'j':
                    new_row.append(align_to_width(row[i], fspec[i]))
            else:
                new_row.append(''.ljust(fspec[i]))

        for i in range(rml_fields[1]+rml_fields[0], rml_fields[2]+rml_fields[1]+rml_fields[0]):
            delta = i - (rml_fields[1]+rml_fields[0])
            if i < len(row):
                if settings['fields'][rml_fields[0]+delta+1][0] == 'l':
                    new_row.append(row[i].ljust(fspec[i]))
                if settings['fields'][rml_fields[0]+delta+1][0] == 'r':
                    new_row.append(row[i].rjust(fspec[i]))
                if settings['fields'][rml_fields[0]+delta+1][0] == 'c':
                    new_row.append(row[i].center(fspec[i]))
                if settings['fields'][rml_fields[0]+delta+1][0] == 'j':
                    new_row.append(align_to_width(row[i], fspec[i]))
            else:
                new_row.append(''.ljust(fspec[i]))
    except:
        perr(str(settings['fields'])+', '+str(rml_fields))

    row = new_row

    str_row += charset['lbv_filling']
    for i in range(len(fspec)):
        if i < len(row):
            # str_row += row[i].ljust(fspec[i])
            str_row += row[i]
        else:
            str_row += ''.ljust(fspec[i])

        if i != len(fspec)-1:
            str_row += charset['v_filling']
    str_row += charset['rbv_filling']
    str_row += '\n'

    settings['output'].write(str_row)

# Making names and delimiter strings and then writing it
def write_names(fspec):
    names = settings['names']
    new_names = []
    str_names = ''

    for i in range(rml_fields[0]):
        if i < len(names):
            if settings['fields'][i][0] == 'l':
                new_names.append(names[i].ljust(fspec[i]))
            if settings['fields'][i][0] == 'r':
                new_names.append(names[i].rjust(fspec[i]))
            if settings['fields'][i][0] == 'c':
                new_names.append(names[i].center(fspec[i]))
            if settings['fields'][i][0] == 'j':
                new_names.append(align_to_width(names[i], fspec[i]))
        else:
            new_names.append(''.ljust(fspec[i]))

    for i in range(rml_fields[0], rml_fields[1]+rml_fields[0]):
        if i < len(names):
            if settings['fields'][rml_fields[0]][0] == 'l':
                new_names.append(names[i].ljust(fspec[i]))
            if settings['fields'][rml_fields[0]][0] == 'r':
                new_names.append(names[i].rjust(fspec[i]))
            if settings['fields'][rml_fields[0]][0] == 'c':
                new_names.append(names[i].center(fspec[i]))
            if settings['fields'][rml_fields[0]][0] == 'j':
                new_names.append(align_to_width(names[i], fspec[i]))
        else:
            new_names.append(''.ljust(fspec[i]))

    for i in range(rml_fields[1]+rml_fields[0], rml_fields[2]+rml_fields[1]+rml_fields[0]):
        delta = i - (rml_fields[1]+rml_fields[0])
        if i < len(names):
            if settings['fields'][rml_fields[0]+delta+1][0] == 'l':
                new_names.append(names[i].ljust(fspec[i]))
            if settings['fields'][rml_fields[0]+delta+1][0] == 'r':
                new_names.append(names[i].rjust(fspec[i]))
            if settings['fields'][rml_fields[0]+delta+1][0] == 'c':
                new_names.append(names[i].center(fspec[i]))
            if settings['fields'][rml_fields[0]+delta+1][0] == 'j':
                new_names.append(align_to_width(names[i], fspec[i]))
        else:
            new_names.append(''.ljust(fspec[i]))

    names = new_names

    str_names += charset['lbv_filling']
    for i in range(len(fspec)):
        if i < len(names):
            # str_names += names[i].ljust(fspec[i])
            str_names += names[i]
        else:
            str_names += ''.ljust(fspec[i])

        if i != len(fspec)-1:
            str_names += charset['v_filling']
    str_names += charset['rbv_filling']
    str_names += '\n'

    settings['output'].write(str_names)

def rearrange_columns(row):
    new_row = ''
    row = split_row(row.rstrip('\n\r'))

    zero_trigger = False

    dont_touch = []

    new_row_left = []
    new_row_mid = []
    new_row_right = []
    new_row_full = []

    for i in range(len(settings['fields'])):
        if int(settings['fields'][i][1:]) == 0:
            zero_trigger = True
            continue
        if not zero_trigger:
            new_row_left.append(row[int(settings['fields'][i][1:])-1])
            dont_touch.append(int(settings['fields'][i][1:])-1)
        else:
            new_row_right.append(row[int(settings['fields'][i][1:])-1])
            dont_touch.append(int(settings['fields'][i][1:])-1)

    if zero_trigger:
        for i in range(len(row)):
            if i in dont_touch:
                continue
            new_row_mid.append(row[i])

    rml_fields[0] = len(new_row_left)
    rml_fields[1] = len(new_row_mid)
    rml_fields[2] = len(new_row_right)

    new_row_full.extend(new_row_left)
    new_row_full.extend(new_row_mid)
    new_row_full.extend(new_row_right)

    for i in range(len(new_row_full)):
        new_row += new_row_full[i]
        if i != len(new_row_full)-1:
            new_row += settings['input_separators'][0]

    return new_row


def main():
    arg_parse()
    set_charset()

    rows = read_first_part()

    try:
        fspec = compute_fields(rows)
        if len(settings['fields']) > len(fspec):
            raise Exception('cannot be more letters than columns in lines inspection rows')
    except Exception as e:
            perr('Invalid argument in option --fields', e)
            sys.exit(1)

    if settings['fields'] != 'f0':
        new_rows = []
        for row in rows:
            new_rows.append(rearrange_columns(row))
        rows = new_rows

    if settings['fl_header'] and rows:
        settings['names'] = split_row(rows[0])
        rows.pop(0)

    fspec = compute_fields(rows)

    if settings['fields'] == 'f0':
        rml_fields[1] = len(fspec)

    if settings['borderline']:
        write_top(fspec)
    write_names(fspec)
    if settings['headerline']:
        write_mid(fspec)

    for row in rows:
        write_row(fspec, row)

    if settings['lines_inspect'] != 0:
        while True:
            row = settings['input'].readline()
            if not row:
                break
            if settings['fields'] != 'f0':
                row = rearrange_columns(row)
            write_row(fspec, row)

    if settings['borderline']:
        write_bot(fspec)

main()